# 继承

    继承可以解决代码复用 让我们的编程更加靠近人类思维 当多个类存在相同的属性 和 方法时 可以从这些类中抽象出父类 在父类中定义这些相同的属性和方法 所有的子类不需要重新定义这些属性和方法 只需要通过extends来声明继承父类即可

    子类会自动拥有父类定义的属性和方法
    父类又叫超类和基类
    子类又叫派生类

## 继承给编程带来的便利
1. 代码复用性
2. 代码的扩展性和维护性

## 细节
1. 子类继承了所有属性和方法 但私有属性不能在子类中直接访问 要通过公共方法去访问
2. 子类必须调用父类的构造器 完成父类的初始化
3. 当创建子类对象时 不管使用子类的哪个构造器 默认的情况下都会去调用父类的无参构造器 如果父类没有提供无参构造器 则必须在子类的构造器中用supper去指定使用父类的哪个构造器完成对父类的初始化工作 否则编译不会通过
4. 如果希望指定去调用父类的某个构造器 则显式调用一下
5. super在使用时放在构造器第一行(只能在构造器中使用)
6. super()和this()都只能放在构造器 第一行 因此这两个方法不能共存在一个构造器
7. java所有类都是Object的子类
8. 父类构造器的调用不限于直接父类 将一直往上追溯到Object类(顶级父类)
9. 子类最多只能继承一个父类(直接继承) 即 java中是单继承机制
10. 不能滥用继承 子类和父类之间必须满足is-a的逻辑关系

## super
super代表父类的引用 用于访问父类的属性 方法 构造器
1. 访问父类的属性 但不能访问父类的private属性 super.属性
2. 访问父类开放的方法 super.方法(参数列表)
3. 访问父类的构造器 super(参数列表)

### 细节
1. 调用父类构造器的好处
   - 分工明确 父类的属性由父类初始化 子类的属性由子类初始化
2. 当子类中有和父类中的成员重名时 为了访问父类的成员 必须通过super
3. super的访问不局限于直接父类 遵循就近原则


## 方法重写 override
    方法重写就是子类有一个方法 和父类的某个方法的名称 返回类型 参数一样 那么我们就说子类的这个方法覆盖了父类的方法

### 细节
1. 子类的方法的参数 方法名称 要和父类的方法参数 方法名称 完全一样
2. 子类的返回类型和父类的返回类型一样 或者是父类返回类型的子类
   - 比如 父类返回 Object 子类返回String
3. 子类方法不能缩小父类方法的访问权限
   - 反之 子类能扩大父类的访问权限